---
title: How to Profile Your Haskell Program - Profiling Project Euler Problem 12
layout: default
---

I was attempting to solve Problem 12 of Project Euler – “What is the value of the first triangle number to have over five hundred divisors?”  I came up with a relatively simple solution, which was not at all optimized, although it seemed to be functionally correct.  However, time to execute was taking ridiculously long – almost a minute for > 100 divisors, and I gave up after waiting 10 minutes for 500 divisors.  Execution time looked to be growing exponentially – I didn't run any real tests to determine its actual big-O, but it was definitely superlinear.  I realized my brute force algorithm was almost certainly the cause of this ugly performance.  However, performance testing in a purely functional language is difficult – I couldn't just add some debug print statements like I would in a traditional imperative language.  Therefore, I had to use a profiler to see what was going on internally.

First off, here is my first crack at Problem 12.  Note that I am exhautively testing for divisors up to n / 2, and I am adding to the end of the list – a O(n) operation when order doesn't matter!  Constructing a list by prefixing it instead of traversing the whole thing and adding it to the end would change at least one operation from O(n) to O(1).

```
import Data.List

getDivisors :: Int -> [Int]
getDivisors x = nub $ [j | j <- [1..(ceiling (fromIntegral x / 2))], x `rem` j == 0] ++ [x]

getNumDivisors :: Int -> Int
getNumDivisors x = length $ getDivisors x

getTriangleNum :: Int -> Int
getTriangleNum x = foldr (+) 0 [1..x]

triList = [j | j <- map (getTriangleNum) [1..]]

triNumXDivisors :: Int -> Int
triNumXDivisors x = head $ [ j | j <- triList, getNumDivisors j > x]
```

The entry point to the program is triNumXDivisors.  This keeps getting entries from the infinite list triList (which contains all triangle numbers, which are numbers of the form 1, 1 + 2, 1 + 2 + 3, 1 + 2 + 3 + 4, etc.).  This list is generated by mapping getTriangleNum over the lazy sequence [1..] (i.e., all natural numbers).  The list comprehension then only takes elements where the number of divisors is greater than some number x.  Since the first value where the number of divisors is greater than x is needed, we get the head of that list.  Haskell's awesome laziness then prevents it from going any further than it needs to – once this list has an element (which will also be the first element) where getNumDivisors is greater than x, it will end and give us the result.
In order to profile your program, you need to leave the cozy confines of the REPL and compile it.  This also means that you need to give the program a main entry point.  I did this in a very simple way, by adding:
main = print (triNumXDivisors 50)
This will only print the result for a relatively small value, 50.  I figured adding anything else would just get in the way of profiling.
Now that I had a compilable program, time to compile it!  The extra arguments are profiler options.
```
$ ghc -prof -fprof-auto -rtsopts Problem12.hs
```

Now I have an executable, Problem12, in the directory.  I run it using the -p option, which will create a file called (executable name).prof.

```
$ ./Problem12 +RTS -p
25200
```

As a side effect of running the executable, the file Problem12.prof was created.  Let's take a look at what's inside:

```
Sun Nov 18 13:20 2012 Time and Allocation Profiling Report (Final)
Problem12 +RTS -p -RTS
total time = 0.13 secs (129 ticks @ 1000 us, 1 processor)
 total alloc = 62,955,328 bytes (excludes profiling overheads)
COST CENTRE MODULE %time %alloc
getDivisors Main 96.1 97.3
 getTriangleNum Main 2.3 2.6
 individual inherited
 COST CENTRE MODULE no. entries %time %alloc %time %alloc
MAIN MAIN 46 0 0.0 0.0 100.0 100.0
 CAF Main 91 0 0.0 0.0 100.0 99.9
 triList Main 94 1 0.8 0.0 3.1 2.6
 getTriangleNum Main 97 224 2.3 2.6 2.3 2.6
 main Main 92 1 0.8 0.0 96.9 97.3
 triNumXDivisors Main 93 1 0.0 0.0 96.1 97.3
 getNumDivisors Main 95 224 0.0 0.0 96.1 97.3
 getDivisors Main 96 224 96.1 97.3 96.1 97.3
 CAF GHC.Conc.Signal 90 0 0.0 0.0 0.0 0.0
 CAF GHC.IO.Encoding 82 0 0.0 0.0 0.0 0.0
 CAF GHC.IO.Encoding.Iconv 80 0 0.0 0.0 0.0 0.0
 CAF GHC.IO.Handle.FD 73 0 0.0 0.1 0.0 0.1
```

That's actually pretty understandable if you've ever worked with a profiling program before.  You've got your total CPU time in a function (%time) and total memory allocated to a function (%alloc) over the course of its lifetime.  That last bit is important because it doesn't mean how much memory a particular function is using at any particular point in time.  Think of it as the integral of memory usage.  The only unfamiliar thing for me was the term CAF.  A bit of Googling led me to a definition on the Haskell wiki – it's a “constant applicative form.”  What's that, you ask?  Well, you may not, but I certainly did.  It's basically any function that doesn't have free variables and isn't a lambda function.  I recommend checking out the linked definition for more details.

Looking at the numbers, there are only two functions which take any non-trivial amount of CPU time, getDivisors and getTriangleNum.  I'm not even really interested in memory allocation at this point since my worry is time – if the reason for the long execution time is because the program is memory-bound, I'll look at it later.  Since getDivisors is by far the biggest CPU hog here, I'm going to work on optimizing it.  As a shortcut, I'm going to use some code of Franklin's and insert it as the new getDivisors function.  Here is my modified version using his algorithm for determining the number of divisors -

```
import Data.List

getDivisors :: Int -> [Int]
getDivisors x = nub $ [j | j <- [1..(ceiling (fromIntegral x / 2))], x `rem` j == 0] ++ [x]

possibleFactors :: [Integer]
possibleFactors = 2 : [3, 5..]

factorFromStream :: Integer -> [Integer] -> [Integer]
n `factorFromStream` factors@(factor:moreFactors)
    | factor*factor > n = [n]
    | otherwise =
      case n `quotRem` factor of
        (q, 0) -> factor : q `factorFromStream` factors
        _      -> n `factorFromStream` moreFactors
factorStream :: Integer -> [Integer]
factorStream n = n `factorFromStream` possibleFactors

countDuplicatesOf :: Eq a => a -> Integer -> [a] -> [Integer]
countDuplicatesOf _ count [] = [count]
countDuplicatesOf x count xs@(y:ys)
 | x == y = countDuplicatesOf x (count+1) ys
 | otherwise = count : countDuplicatesOf y 1 ys

countDuplicates :: Eq a => [a] -> [Integer]
countDuplicates [] = []
countDuplicates (x:xs) = countDuplicatesOf x 1 xs

factorCounts :: Integer -> [Integer]
factorCounts = countDuplicates . factorStream

getNumDivisors :: Integer -> Integer
getNumDivisors 1 = 1
getNumDivisors x = product [m+1 | m <- factorCounts x]

getTriangleNum :: Integer -> Integer
getTriangleNum x = foldr (+) 0 [1..x]

triList = [j | j <- map (getTriangleNum) [1..]]

triNumXDivisors :: Integer -> Integer
triNumXDivisors x = head $ [ j | j <- triList, getNumDivisors j > x]

main = print (triNumXDivisors 50)
```

This looks a little more complicated, but the only real change is the in the call stack behind getDivisors – it's going to use a much more efficient algorithm than the brute force list comprehension I made the first time.  After compiling and getting the profiler statistics from this program, let's see what sort of CPU usage we're seeing now:

```
Sun Nov 18 13:29 2012 Time and Allocation Profiling Report (Final)
Problem12 +RTS -p -RTS
total time = 0.01 secs (5 ticks @ 1000 us, 1 processor)
 total alloc = 1,967,248 bytes (excludes profiling overheads)
COST CENTRE MODULE %time %alloc
getTriangleNum Main 60.0 82.7
getNumDivisors Main 20.0 3.7
factorFromStream Main 20.0 8.1
CAF GHC.IO.Handle.FD 0.0 1.7
countDuplicatesOf Main 0.0 1.5
triList Main 0.0 1.2
 individual inherited
COST CENTRE MODULE no. entries %time %alloc %time %alloc
MAIN MAIN 46 0 0.0 0.0 100.0 100.0
 CAF Main 91 0 0.0 0.0 100.0 98.2
 possibleFactors Main 102 1 0.0 0.1 0.0 0.1
 factorCounts Main 97 1 0.0 0.0 0.0 0.0
 triList Main 94 1 0.0 1.2 60.0 83.9
 getTriangleNum Main 96 224 60.0 82.7 60.0 82.7
 main Main 92 1 0.0 0.5 40.0 14.2
 triNumXDivisors Main 93 1 0.0 0.1 40.0 13.7
 getNumDivisors Main 95 224 20.0 3.7 40.0 13.6
 factorCounts Main 98 0 0.0 0.2 20.0 9.9
 factorStream Main 100 223 0.0 0.0 20.0 8.1
 factorFromStream Main 101 2597 20.0 8.1 20.0 8.1
 countDuplicates Main 99 223 0.0 0.1 0.0 1.6
 countDuplicatesOf Main 103 936 0.0 1.5 0.0 1.5
 CAF GHC.Conc.Signal 90 0 0.0 0.0 0.0 0.0
 CAF GHC.IO.Encoding 83 0 0.0 0.1 0.0 0.1
 CAF GHC.IO.Encoding.Iconv 81 0 0.0 0.0 0.0 0.0
 CAF GHC.IO.Handle.FD 74 0 0.0 1.7 0.0 1.7
```

Wow!  Note that getTriangleNum, which used to be taking 2.7% CPU time, is now far and away the largest consumer of CPU at 60.0%.  getDivisors (and one of the functions it uses, factorFromStream) together take up 40% of CPU (with minimal amounts being used by other functions).  We also went from 0.13 seconds to calculate to 0.01.  So getTriangleNum would now be the bottleneck, but I think we now have sufficient speed to hit the n > 500 mark within a reasonable amount of time.  Let's try this with several values of n, just to check out the growth while we're at it.  All time values are from using the UNIX time command and adding user and sys time.

```
n > 50 : 12 ms (milliseconds)
n > 100 : 21 ms
n > 200 : 340 ms
n > 300 : 364 ms
n > 400 : 3165 ms
n > 500 : 15663 ms
```

This rate of growth seemed interesting to me, although not totally unexpected.  After all, it's not a linear path from n > 50 to n > 100 (remember that we're looking for when the number of divisors crosses that threshold, and there's no telling when that will happen).  I ran a n > 500 run with the profiler again and found this:

```
COST CENTRE MODULE %time %alloc
getTriangleNum Main 96.7 97.8
factorFromStream Main 3.0 2.0
```

getTriangleNum – which gets the nth triangle number – used to be an afterthought at 2.7% CPU time.  Now it has switched places with the divisor-getting function and is the new bottleneck as n increased!  It just goes to show you that you need to check for growth rates as well as snapshots for certain values.

Note: Most of what I did was apply the information found in the Haskell Users' Guide, Chapter 5 to my own program.  There's plenty more useful information there.