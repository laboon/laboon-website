<!DOCTYPE html>

<html>
    <head>
        <meta charset="utf-8"/>
        <title> Global Day of Code Retreat 2012 - Impressions from Pittsburgh |  Bill Laboon: On Programming</title>
        <link rel="stylesheet" href="/style.css" />
        <meta name="description" content="Blog on Software Development, Computer Science, Quality Assurance and Related Matter"/>

        <!--[if IE 7]><link rel="stylesheet" href="/resources/fontello/css/fontello-ie7.css"><![endif]-->
    </head>

    <body>
        <header>
            <h1><a href="/">Bill Laboon: On Programming</a></h1>
                <h4>Blog on Software Development, Computer Science, Quality Assurance and Related Matter</h4>

	    <p>[<a title="[GitHub]" href="http://www.github.com/laboon">Github</a>]
	       [<a title="[Twitter]" href="https://twitter.com/billlaboon">Twitter</a>]
	       [<a title="[Infinite Viral]" href="http://infiniteviral.com">Infinite Viral</a>]</p>

            <hr />
        </header>

        <main>

            <p>Yesterday, 8 December 2012, I (along with over 3,500 other software developers) took part in the 2012 Global Day of Code Retreat.  This was my first code retreat, and going into it, I wasn't sure what to expect.  I googled and asked some of my friends who had been to previous ones, but it still seemed pretty mysterious to me.  A bunch of people sit around programming Conway's Game of Life, but with different restrictions?  Sounds intriguing, but I still wasn't sure what would actually happen.  I told myself I'd write up a blog post with a blow-by-blow the next day to help other people who were deciding whether or not to sign up.  Spoiler alert: this was one of most fun and helpful days I have had as a programmer, and I have been programming for a long time.</p>

<p>The Pittsburgh GDCR was held at Pittsburgh Technical Institute (PTI), a two-year college out by the Pittsburgh airport (and coincidentally, my brother's alma mater).  Since I live in the East End, I knew it was going to be quite a drive in the morning.  The night before, I checked for directions as well as gathering up the materials the GDCR site said I might need: a laptop with development tools, keyboard and mouse for pairing, a power cord, and my tickets.  I packed them all up in my laptop bag (although the keyboard didn't fit very well) and went to sleep, happy to be so prepared.  I knew I wasn't going to want to try finding everything in the morning, and if I had tried doing that, I probably would have forgotten something important.</p>

<p>The morning of the event, I woke up at 6:30 AM, and by 7:30 I was driving out to PTI, fueled only with adrenaline and a grande peppermint mocha from Starbucks (Saturday morning mochas are a tradition for me).  The event was supposed to start at 8:30, but since there was absolutely no traffic on the way in, I got there at 8:00, making me one of the first people to arrive.  We had been warned that there may not be Internet access, so I took the extra time to talk with the receptionist about setting up my Internet.  This meant that for the rest of the day, I was one of the only people accessing the PTI Internet.  There were a few others who had cellular access.  This honestly didn't matter much – I spent much less time researching syntax than I thought I was going to, even though I spent quite a bit of time working in languages I'd never seen before!</p>

<p>I chatted with one of the organizers for a bit, then picked up my name tag, which noted that I knew Ruby and Haskell.  Ahh, I remember, it said which languages did you WANT to program in, not which ones you knew.  I keep trying to improve my functional programming abilities, but my main language is still Java.  I added Java and Perl to my name tag, and thought about adding more, but ended up talking with too many people in the pre-conference stage.  I ended up running into many people that I already knew from various other parts of my life – such as Dan Buch (from Modcloth), Bruce Adams (from Pittsburgh Clojure User Group), Carol Nichols, Jake Goulding, and Corey Purcell (all from Pittsburgh Ruby Brigade).  Unsurprisingly, since Corey Haines is a prominent Rubyist, this was a pretty Ruby-heavy event, although I also ended up working in Java, C#, and Python.</p>

<p>What surprised me the most about the event was that this truly was a Global Day of Code Retreat.  After some discussion about what we would be doing, we got to interact with other Code Retreats happening all around the world.  This included two teams from Israel, a team from the UK, one from Mexico, and a special treat at the end of the day – a very tired-looking Corey Haines, founder of Code Retreat, from the event in Hawai'i.  I'm getting ahead of myself here, but it was really cool to talk to people from other countries doing exactly what you're doing, people care so much about refining their programming that they took a day out of their lives and spent it with a bunch of nerds like me.</p>

<p>After filling up on coffee, we (all 32, or 2<sup>5</sup>, of us) moved to a classroom where Joe Kramer, one of the facilitators, discussed the Four Rules of Simple Design:</p>

<ol>
<li>Tests pass (which implies, of course, that tests exist!)</li>
<li>Clarity (“reveal your intent”)</li>
<li>Simplest design possible (minimal amount of code)</li>
<li>DRY (Don't repeat yourself!)</li>
</ol>


<p>These became a running theme throughout the day; we would discuss how the different exercises impacted the four rules.</p>

<p>With that, we were off and Joe asked us to find a partner for pair programming.  I ended up with a guy named Greg Hopkins, a Python developer.  We couldn't agree on whether or not to use Python or Ruby, so we did rock-paper-scissors for it (we figured this would be the easiest way to decide).  I want to emphasize that this was all in good fun, we weren't actually arguing about code, just trying to quickly come up with a lingua franca for our first pairing.  I won, so we started with Ruby.  I had to install the Test::Unit gem quickly (thank goodness I got an Internet connection that morning), and we started working on the Tests Fail -> Tests Pass -> Refactor loop.  Greg taught me quite a bit about Test-Driven Development (TDD), which I understood in passing but didn't have much experience with.  After forty-five minutes, we didn't have much done, but it was a good framework.  At that point, Joe told us to erase all of our code and stand up!  I'll be honest, this first time, it was a little painful.  However, the point of Code Retreat isn't the end result, it's the process.  The Game of Life is just a MacGuffin and ancillary to the actual result of honing your craft.  It's just like throwing away your early sketches to work on your magnum opus later.</p>

<p>There was a ten-minute break, during which I ended up talking to a student from PTI, JT.  I was impressed that he would come out to an event like this of his own accord (he was joking with one of the professors about getting extra credit from it, which means he didn't get any in the first place).  We ended up pairing for the next session, which had the following restrictions:</p>

<ol>
<li>No conditionals</li>
<li>No methods longer than four lines</li>
<li>No naked primitives</li>
</ol>


<p>Honestly, the latter two restrictions were not that difficult.  It's relatively simple to wrap everything in a class (also known as, “getting drunk on object orientation”) and add some getters and setters, and push everything into small methods instead of big ones.  Getting it to work without conditionals was difficult, though.  The only language JT and I had in common was Java, and he was a relatively new programmer and I didn't want to spend time teaching a new language at this point.  We spent a long time trying to think of simple ways around it, but we just didn't get it in time.  Before we knew it, time was up, and we erased all of our code and stood up.  Nobody had finished a working game of Life, of course.  We discussed our various approaches to avoiding conditionals (which seemed to be the sticking point for everyone).</p>

<p>The next session was “mute ping-pong naive coding” – which is a mouthful, but the concept was simple once we started doing it.  Basically, you pair but can't talk.  At all.  One programmer writes tests, and then the other writes code that makes the tests pass.  However, the “coder” (as opposed to the tester) has no concept of the game of life – he/she is just trying to get the tests to pass.  This ensures that you think about test creation and writing code to pass those tests.  I ended up pairing with a Duquesne University student named Liz who was really excited about learning Ruby (Carol and she had paired earlier, and was apparently a good evangelist!).  We didn't know the exercise until after we had decided on Ruby, a language she didn't know, which made this especially interesting.</p>

<p>I was the tester, so I wrote some code up.  Unfortunately, things were going slowly due to her having to look up syntax, so I made it a little easier by adding some “framework” code for her to fill in.  This may have been breaking the letter of the law in mute ping-pong, but I think it was still in keeping with the spirit.  It was really fun to teach someone Ruby in this method, and she was really excited, so much so that at the end of the day she mentioned how much she wanted to learn Ruby more.  Another convert!  She also had a math background, so I spent some time discussing functional programming afterwards, which to me seems a more mathematical way of looking at coding.</p>

<p>At this point, it was 11:30 and I was ready for lunch.  Alas, it was not to be.  I paired with another PTI student, Tyler, and we once again worked in Java.  The restriction this time was simple: no return values!  This is something that is almost unthinkable for modern programmers.  After a bit of cobweb clearing, however, I remember the last time I did programming without return statements – programming BASIC on an old Commodore 64.  Yes, I felt like an old-timer, but I showed Tyler some old-school procedural programming with all global variables and no methods, just one giant static Java void method.  We actually had an almost-working version at the end of 45 minutes!  It just didn't iterate more than once – we knew that, just didn't have a chance to add a while(true) loop before time was up.  Nobody else thought to do this; guess there are some perks to being an old fuddy-duddy.  As I mentioned at the end, “I never thought I would use my old Commodore 64 BASIC skills again!”</p>

<p>It was time for lunch after that demonstration of the power of 1982-style programming.  Over sandwiches, I discussed how to introduce more testing into the software development process with a couple of people from Modcloth and Corey.  Taking our cue from the British team we had talked with earlier, I kept my food intake to a mininum… no after-lunch carb coma for me!</p>

<p>The next session was speed programming, which I ended up doing in Java again.  Pairs were divided into a tester and a coder.  This time, I was the coder and my pair partner, Stephen Ramusivich, was the tester.  Basically, a timer was started, and the tester had five minutes to write a valid test and check it in to source control (we used git, since we both knew it).  Then the timer was restarted, and the coder had five minutes to write code to make the test pass.  If you didn't finish in five minutes, you had to revert back to the previous version!  After a while, this time limit went down to three minutes… then two minutes… then one minute… then 30 seconds!  This was probably the most fun and stressful part of the day.  I'll be honest, at 30 seconds, we could get nothing done.  However, I was able to get the “number of neighbors” function working in 59 seconds, checking it in just as the buzzer went off.  I am still inordinately proud of that.</p>

<p>The last session of the day was speed pairing.  This consisted of two roles – a “host” on whose laptop we worked, and a “visitor” who would move from host to host every seven minutes.  I was a visitor, and got to see several different languages at this point: Java, Python, Ruby, and quite a few people working on C#.  It was interesting to see how much more difficult it became to explain things as the speed pairing progressed.  This was a new  type of session, so we came up with various ideas to help improve it for next time, such as going back to the original person at the end of the speed pairing to see how the code progressed.</p>

<p>Finally, it was the end of the day.  There was a raffle for some prizes from the sponsors, and then we had a Code Retreat Circle, where everybody had to say three things:</p>

<ol>
<li>What surprised you about the event?</li>
<li>What did you learn?</li>
<li>What are you going to do differently Monday?</li>
</ol>


<p>I answered that I was surprised that my BASIC programming skills came in handy, I learned about TDD, and I planned to take some of the things I learned about implementing TDD and try to use them at work.  After going home (and battling the now-horrible traffic on the Parkway), I was entirely exhausted and starving.  It was a similar feeling to what I called a “chess hangover” – the feeling of satisfaction but deep mental exhaustion after a day of playing chess.  Not a surprise since I was using my brain in somewhat similar ways all day.</p>

<p>All in all, I highly recommend going to a Code Retreat.  I am certainly a better programmer today than I was on Friday, and that's probably the best endorsement one could give.</p>


        </main>

        <footer>
            <hr />
            <p>&copy; <time>2014</time> Bill Laboon</p>
        </footer>

        <script src="/scripts.js"></script>
    </body>

</html>
